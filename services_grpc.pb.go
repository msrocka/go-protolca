// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package protolca

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// DataServiceClient is the client API for DataService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DataServiceClient interface {
	// Deletes the object with the `id` and `type` of the given descriptor from
	// the database. Note that the type is a string with the name of the
	// corresponding model class, e.g. `Process` or `Flow`.
	Delete(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*Status, error)
	// Get all descriptors that match the given request.
	GetDescriptors(ctx context.Context, in *DescriptorRequest, opts ...grpc.CallOption) (DataService_GetDescriptorsClient, error)
	// Get the first descriptor that matches the given request.
	GetDescriptor(ctx context.Context, in *DescriptorRequest, opts ...grpc.CallOption) (*RefStatus, error)
	// Search for data sets.
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (DataService_SearchClient, error)
	// Creates a new product system.
	CreateProductSystem(ctx context.Context, in *CreateSystemRequest, opts ...grpc.CallOption) (*RefStatus, error)
	// methods for Actor
	GetActors(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetActorsClient, error)
	GetActor(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*ActorStatus, error)
	PutActor(ctx context.Context, in *Actor, opts ...grpc.CallOption) (*RefStatus, error)
	// methods for Category
	GetCategories(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetCategoriesClient, error)
	GetCategory(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*CategoryStatus, error)
	PutCategory(ctx context.Context, in *Category, opts ...grpc.CallOption) (*RefStatus, error)
	// methods for Currency
	GetCurrencies(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetCurrenciesClient, error)
	GetCurrency(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*CurrencyStatus, error)
	PutCurrency(ctx context.Context, in *Currency, opts ...grpc.CallOption) (*RefStatus, error)
	// methods for DQSystem
	GetDQSystems(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetDQSystemsClient, error)
	GetDQSystem(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*DQSystemStatus, error)
	PutDQSystem(ctx context.Context, in *DQSystem, opts ...grpc.CallOption) (*RefStatus, error)
	// methods for Flow
	GetFlows(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetFlowsClient, error)
	GetFlow(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*FlowStatus, error)
	PutFlow(ctx context.Context, in *Flow, opts ...grpc.CallOption) (*RefStatus, error)
	// methods for FlowProperty
	GetFlowProperties(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetFlowPropertiesClient, error)
	GetFlowProperty(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*FlowPropertyStatus, error)
	PutFlowProperty(ctx context.Context, in *FlowProperty, opts ...grpc.CallOption) (*RefStatus, error)
	// methods for ImpactCategory
	GetImpactCategories(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetImpactCategoriesClient, error)
	GetImpactCategory(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*ImpactCategoryStatus, error)
	PutImpactCategory(ctx context.Context, in *ImpactCategory, opts ...grpc.CallOption) (*RefStatus, error)
	// methods for ImpactMethod
	GetImpactMethods(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetImpactMethodsClient, error)
	GetImpactMethod(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*ImpactMethodStatus, error)
	PutImpactMethod(ctx context.Context, in *ImpactMethod, opts ...grpc.CallOption) (*RefStatus, error)
	// methods for Location
	GetLocations(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetLocationsClient, error)
	GetLocation(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*LocationStatus, error)
	PutLocation(ctx context.Context, in *Location, opts ...grpc.CallOption) (*RefStatus, error)
	// methods for Parameter
	GetParameters(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetParametersClient, error)
	GetParameter(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*ParameterStatus, error)
	PutParameter(ctx context.Context, in *Parameter, opts ...grpc.CallOption) (*RefStatus, error)
	// methods for Process
	GetProcesses(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetProcessesClient, error)
	GetProcess(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*ProcessStatus, error)
	PutProcess(ctx context.Context, in *Process, opts ...grpc.CallOption) (*RefStatus, error)
	// methods for ProductSystem
	GetProductSystems(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetProductSystemsClient, error)
	GetProductSystem(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*ProductSystemStatus, error)
	PutProductSystem(ctx context.Context, in *ProductSystem, opts ...grpc.CallOption) (*RefStatus, error)
	// methods for Project
	GetProjects(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetProjectsClient, error)
	GetProject(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*ProjectStatus, error)
	PutProject(ctx context.Context, in *Project, opts ...grpc.CallOption) (*RefStatus, error)
	// methods for SocialIndicator
	GetSocialIndicators(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetSocialIndicatorsClient, error)
	GetSocialIndicator(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*SocialIndicatorStatus, error)
	PutSocialIndicator(ctx context.Context, in *SocialIndicator, opts ...grpc.CallOption) (*RefStatus, error)
	// methods for Source
	GetSources(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetSourcesClient, error)
	GetSource(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*SourceStatus, error)
	PutSource(ctx context.Context, in *Source, opts ...grpc.CallOption) (*RefStatus, error)
	// methods for UnitGroup
	GetUnitGroups(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetUnitGroupsClient, error)
	GetUnitGroup(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*UnitGroupStatus, error)
	PutUnitGroup(ctx context.Context, in *UnitGroup, opts ...grpc.CallOption) (*RefStatus, error)
	// Get possible providers for the given flow. For products
	// these are processes with that product on the output side
	// and for waste flows processes with that waste flow on the
	// input side. For elementary flows, an empty stream is
	// returned.
	GetProvidersFor(ctx context.Context, in *Ref, opts ...grpc.CallOption) (DataService_GetProvidersForClient, error)
}

type dataServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDataServiceClient(cc grpc.ClientConnInterface) DataServiceClient {
	return &dataServiceClient{cc}
}

func (c *dataServiceClient) Delete(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetDescriptors(ctx context.Context, in *DescriptorRequest, opts ...grpc.CallOption) (DataService_GetDescriptorsClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[0], "/protolca.services.DataService/GetDescriptors", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetDescriptorsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_GetDescriptorsClient interface {
	Recv() (*Ref, error)
	grpc.ClientStream
}

type dataServiceGetDescriptorsClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetDescriptorsClient) Recv() (*Ref, error) {
	m := new(Ref)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) GetDescriptor(ctx context.Context, in *DescriptorRequest, opts ...grpc.CallOption) (*RefStatus, error) {
	out := new(RefStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/GetDescriptor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (DataService_SearchClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[1], "/protolca.services.DataService/Search", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceSearchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_SearchClient interface {
	Recv() (*Ref, error)
	grpc.ClientStream
}

type dataServiceSearchClient struct {
	grpc.ClientStream
}

func (x *dataServiceSearchClient) Recv() (*Ref, error) {
	m := new(Ref)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) CreateProductSystem(ctx context.Context, in *CreateSystemRequest, opts ...grpc.CallOption) (*RefStatus, error) {
	out := new(RefStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/CreateProductSystem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetActors(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetActorsClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[2], "/protolca.services.DataService/GetActors", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetActorsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_GetActorsClient interface {
	Recv() (*Actor, error)
	grpc.ClientStream
}

type dataServiceGetActorsClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetActorsClient) Recv() (*Actor, error) {
	m := new(Actor)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) GetActor(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*ActorStatus, error) {
	out := new(ActorStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/GetActor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) PutActor(ctx context.Context, in *Actor, opts ...grpc.CallOption) (*RefStatus, error) {
	out := new(RefStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/PutActor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetCategories(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetCategoriesClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[3], "/protolca.services.DataService/GetCategories", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetCategoriesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_GetCategoriesClient interface {
	Recv() (*Category, error)
	grpc.ClientStream
}

type dataServiceGetCategoriesClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetCategoriesClient) Recv() (*Category, error) {
	m := new(Category)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) GetCategory(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*CategoryStatus, error) {
	out := new(CategoryStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/GetCategory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) PutCategory(ctx context.Context, in *Category, opts ...grpc.CallOption) (*RefStatus, error) {
	out := new(RefStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/PutCategory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetCurrencies(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetCurrenciesClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[4], "/protolca.services.DataService/GetCurrencies", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetCurrenciesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_GetCurrenciesClient interface {
	Recv() (*Currency, error)
	grpc.ClientStream
}

type dataServiceGetCurrenciesClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetCurrenciesClient) Recv() (*Currency, error) {
	m := new(Currency)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) GetCurrency(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*CurrencyStatus, error) {
	out := new(CurrencyStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/GetCurrency", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) PutCurrency(ctx context.Context, in *Currency, opts ...grpc.CallOption) (*RefStatus, error) {
	out := new(RefStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/PutCurrency", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetDQSystems(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetDQSystemsClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[5], "/protolca.services.DataService/GetDQSystems", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetDQSystemsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_GetDQSystemsClient interface {
	Recv() (*DQSystem, error)
	grpc.ClientStream
}

type dataServiceGetDQSystemsClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetDQSystemsClient) Recv() (*DQSystem, error) {
	m := new(DQSystem)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) GetDQSystem(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*DQSystemStatus, error) {
	out := new(DQSystemStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/GetDQSystem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) PutDQSystem(ctx context.Context, in *DQSystem, opts ...grpc.CallOption) (*RefStatus, error) {
	out := new(RefStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/PutDQSystem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetFlows(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetFlowsClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[6], "/protolca.services.DataService/GetFlows", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetFlowsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_GetFlowsClient interface {
	Recv() (*Flow, error)
	grpc.ClientStream
}

type dataServiceGetFlowsClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetFlowsClient) Recv() (*Flow, error) {
	m := new(Flow)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) GetFlow(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*FlowStatus, error) {
	out := new(FlowStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/GetFlow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) PutFlow(ctx context.Context, in *Flow, opts ...grpc.CallOption) (*RefStatus, error) {
	out := new(RefStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/PutFlow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetFlowProperties(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetFlowPropertiesClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[7], "/protolca.services.DataService/GetFlowProperties", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetFlowPropertiesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_GetFlowPropertiesClient interface {
	Recv() (*FlowProperty, error)
	grpc.ClientStream
}

type dataServiceGetFlowPropertiesClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetFlowPropertiesClient) Recv() (*FlowProperty, error) {
	m := new(FlowProperty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) GetFlowProperty(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*FlowPropertyStatus, error) {
	out := new(FlowPropertyStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/GetFlowProperty", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) PutFlowProperty(ctx context.Context, in *FlowProperty, opts ...grpc.CallOption) (*RefStatus, error) {
	out := new(RefStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/PutFlowProperty", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetImpactCategories(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetImpactCategoriesClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[8], "/protolca.services.DataService/GetImpactCategories", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetImpactCategoriesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_GetImpactCategoriesClient interface {
	Recv() (*ImpactCategory, error)
	grpc.ClientStream
}

type dataServiceGetImpactCategoriesClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetImpactCategoriesClient) Recv() (*ImpactCategory, error) {
	m := new(ImpactCategory)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) GetImpactCategory(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*ImpactCategoryStatus, error) {
	out := new(ImpactCategoryStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/GetImpactCategory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) PutImpactCategory(ctx context.Context, in *ImpactCategory, opts ...grpc.CallOption) (*RefStatus, error) {
	out := new(RefStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/PutImpactCategory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetImpactMethods(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetImpactMethodsClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[9], "/protolca.services.DataService/GetImpactMethods", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetImpactMethodsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_GetImpactMethodsClient interface {
	Recv() (*ImpactMethod, error)
	grpc.ClientStream
}

type dataServiceGetImpactMethodsClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetImpactMethodsClient) Recv() (*ImpactMethod, error) {
	m := new(ImpactMethod)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) GetImpactMethod(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*ImpactMethodStatus, error) {
	out := new(ImpactMethodStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/GetImpactMethod", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) PutImpactMethod(ctx context.Context, in *ImpactMethod, opts ...grpc.CallOption) (*RefStatus, error) {
	out := new(RefStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/PutImpactMethod", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetLocations(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetLocationsClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[10], "/protolca.services.DataService/GetLocations", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetLocationsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_GetLocationsClient interface {
	Recv() (*Location, error)
	grpc.ClientStream
}

type dataServiceGetLocationsClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetLocationsClient) Recv() (*Location, error) {
	m := new(Location)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) GetLocation(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*LocationStatus, error) {
	out := new(LocationStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/GetLocation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) PutLocation(ctx context.Context, in *Location, opts ...grpc.CallOption) (*RefStatus, error) {
	out := new(RefStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/PutLocation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetParameters(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetParametersClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[11], "/protolca.services.DataService/GetParameters", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetParametersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_GetParametersClient interface {
	Recv() (*Parameter, error)
	grpc.ClientStream
}

type dataServiceGetParametersClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetParametersClient) Recv() (*Parameter, error) {
	m := new(Parameter)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) GetParameter(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*ParameterStatus, error) {
	out := new(ParameterStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/GetParameter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) PutParameter(ctx context.Context, in *Parameter, opts ...grpc.CallOption) (*RefStatus, error) {
	out := new(RefStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/PutParameter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetProcesses(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetProcessesClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[12], "/protolca.services.DataService/GetProcesses", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetProcessesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_GetProcessesClient interface {
	Recv() (*Process, error)
	grpc.ClientStream
}

type dataServiceGetProcessesClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetProcessesClient) Recv() (*Process, error) {
	m := new(Process)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) GetProcess(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*ProcessStatus, error) {
	out := new(ProcessStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/GetProcess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) PutProcess(ctx context.Context, in *Process, opts ...grpc.CallOption) (*RefStatus, error) {
	out := new(RefStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/PutProcess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetProductSystems(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetProductSystemsClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[13], "/protolca.services.DataService/GetProductSystems", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetProductSystemsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_GetProductSystemsClient interface {
	Recv() (*ProductSystem, error)
	grpc.ClientStream
}

type dataServiceGetProductSystemsClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetProductSystemsClient) Recv() (*ProductSystem, error) {
	m := new(ProductSystem)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) GetProductSystem(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*ProductSystemStatus, error) {
	out := new(ProductSystemStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/GetProductSystem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) PutProductSystem(ctx context.Context, in *ProductSystem, opts ...grpc.CallOption) (*RefStatus, error) {
	out := new(RefStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/PutProductSystem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetProjects(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetProjectsClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[14], "/protolca.services.DataService/GetProjects", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetProjectsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_GetProjectsClient interface {
	Recv() (*Project, error)
	grpc.ClientStream
}

type dataServiceGetProjectsClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetProjectsClient) Recv() (*Project, error) {
	m := new(Project)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) GetProject(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*ProjectStatus, error) {
	out := new(ProjectStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/GetProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) PutProject(ctx context.Context, in *Project, opts ...grpc.CallOption) (*RefStatus, error) {
	out := new(RefStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/PutProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetSocialIndicators(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetSocialIndicatorsClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[15], "/protolca.services.DataService/GetSocialIndicators", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetSocialIndicatorsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_GetSocialIndicatorsClient interface {
	Recv() (*SocialIndicator, error)
	grpc.ClientStream
}

type dataServiceGetSocialIndicatorsClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetSocialIndicatorsClient) Recv() (*SocialIndicator, error) {
	m := new(SocialIndicator)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) GetSocialIndicator(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*SocialIndicatorStatus, error) {
	out := new(SocialIndicatorStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/GetSocialIndicator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) PutSocialIndicator(ctx context.Context, in *SocialIndicator, opts ...grpc.CallOption) (*RefStatus, error) {
	out := new(RefStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/PutSocialIndicator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetSources(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetSourcesClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[16], "/protolca.services.DataService/GetSources", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetSourcesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_GetSourcesClient interface {
	Recv() (*Source, error)
	grpc.ClientStream
}

type dataServiceGetSourcesClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetSourcesClient) Recv() (*Source, error) {
	m := new(Source)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) GetSource(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*SourceStatus, error) {
	out := new(SourceStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/GetSource", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) PutSource(ctx context.Context, in *Source, opts ...grpc.CallOption) (*RefStatus, error) {
	out := new(RefStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/PutSource", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetUnitGroups(ctx context.Context, in *Empty, opts ...grpc.CallOption) (DataService_GetUnitGroupsClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[17], "/protolca.services.DataService/GetUnitGroups", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetUnitGroupsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_GetUnitGroupsClient interface {
	Recv() (*UnitGroup, error)
	grpc.ClientStream
}

type dataServiceGetUnitGroupsClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetUnitGroupsClient) Recv() (*UnitGroup, error) {
	m := new(UnitGroup)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) GetUnitGroup(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*UnitGroupStatus, error) {
	out := new(UnitGroupStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/GetUnitGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) PutUnitGroup(ctx context.Context, in *UnitGroup, opts ...grpc.CallOption) (*RefStatus, error) {
	out := new(RefStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.DataService/PutUnitGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetProvidersFor(ctx context.Context, in *Ref, opts ...grpc.CallOption) (DataService_GetProvidersForClient, error) {
	stream, err := c.cc.NewStream(ctx, &DataService_ServiceDesc.Streams[18], "/protolca.services.DataService/GetProvidersFor", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetProvidersForClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_GetProvidersForClient interface {
	Recv() (*Ref, error)
	grpc.ClientStream
}

type dataServiceGetProvidersForClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetProvidersForClient) Recv() (*Ref, error) {
	m := new(Ref)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DataServiceServer is the server API for DataService service.
// All implementations must embed UnimplementedDataServiceServer
// for forward compatibility
type DataServiceServer interface {
	// Deletes the object with the `id` and `type` of the given descriptor from
	// the database. Note that the type is a string with the name of the
	// corresponding model class, e.g. `Process` or `Flow`.
	Delete(context.Context, *Ref) (*Status, error)
	// Get all descriptors that match the given request.
	GetDescriptors(*DescriptorRequest, DataService_GetDescriptorsServer) error
	// Get the first descriptor that matches the given request.
	GetDescriptor(context.Context, *DescriptorRequest) (*RefStatus, error)
	// Search for data sets.
	Search(*SearchRequest, DataService_SearchServer) error
	// Creates a new product system.
	CreateProductSystem(context.Context, *CreateSystemRequest) (*RefStatus, error)
	// methods for Actor
	GetActors(*Empty, DataService_GetActorsServer) error
	GetActor(context.Context, *Ref) (*ActorStatus, error)
	PutActor(context.Context, *Actor) (*RefStatus, error)
	// methods for Category
	GetCategories(*Empty, DataService_GetCategoriesServer) error
	GetCategory(context.Context, *Ref) (*CategoryStatus, error)
	PutCategory(context.Context, *Category) (*RefStatus, error)
	// methods for Currency
	GetCurrencies(*Empty, DataService_GetCurrenciesServer) error
	GetCurrency(context.Context, *Ref) (*CurrencyStatus, error)
	PutCurrency(context.Context, *Currency) (*RefStatus, error)
	// methods for DQSystem
	GetDQSystems(*Empty, DataService_GetDQSystemsServer) error
	GetDQSystem(context.Context, *Ref) (*DQSystemStatus, error)
	PutDQSystem(context.Context, *DQSystem) (*RefStatus, error)
	// methods for Flow
	GetFlows(*Empty, DataService_GetFlowsServer) error
	GetFlow(context.Context, *Ref) (*FlowStatus, error)
	PutFlow(context.Context, *Flow) (*RefStatus, error)
	// methods for FlowProperty
	GetFlowProperties(*Empty, DataService_GetFlowPropertiesServer) error
	GetFlowProperty(context.Context, *Ref) (*FlowPropertyStatus, error)
	PutFlowProperty(context.Context, *FlowProperty) (*RefStatus, error)
	// methods for ImpactCategory
	GetImpactCategories(*Empty, DataService_GetImpactCategoriesServer) error
	GetImpactCategory(context.Context, *Ref) (*ImpactCategoryStatus, error)
	PutImpactCategory(context.Context, *ImpactCategory) (*RefStatus, error)
	// methods for ImpactMethod
	GetImpactMethods(*Empty, DataService_GetImpactMethodsServer) error
	GetImpactMethod(context.Context, *Ref) (*ImpactMethodStatus, error)
	PutImpactMethod(context.Context, *ImpactMethod) (*RefStatus, error)
	// methods for Location
	GetLocations(*Empty, DataService_GetLocationsServer) error
	GetLocation(context.Context, *Ref) (*LocationStatus, error)
	PutLocation(context.Context, *Location) (*RefStatus, error)
	// methods for Parameter
	GetParameters(*Empty, DataService_GetParametersServer) error
	GetParameter(context.Context, *Ref) (*ParameterStatus, error)
	PutParameter(context.Context, *Parameter) (*RefStatus, error)
	// methods for Process
	GetProcesses(*Empty, DataService_GetProcessesServer) error
	GetProcess(context.Context, *Ref) (*ProcessStatus, error)
	PutProcess(context.Context, *Process) (*RefStatus, error)
	// methods for ProductSystem
	GetProductSystems(*Empty, DataService_GetProductSystemsServer) error
	GetProductSystem(context.Context, *Ref) (*ProductSystemStatus, error)
	PutProductSystem(context.Context, *ProductSystem) (*RefStatus, error)
	// methods for Project
	GetProjects(*Empty, DataService_GetProjectsServer) error
	GetProject(context.Context, *Ref) (*ProjectStatus, error)
	PutProject(context.Context, *Project) (*RefStatus, error)
	// methods for SocialIndicator
	GetSocialIndicators(*Empty, DataService_GetSocialIndicatorsServer) error
	GetSocialIndicator(context.Context, *Ref) (*SocialIndicatorStatus, error)
	PutSocialIndicator(context.Context, *SocialIndicator) (*RefStatus, error)
	// methods for Source
	GetSources(*Empty, DataService_GetSourcesServer) error
	GetSource(context.Context, *Ref) (*SourceStatus, error)
	PutSource(context.Context, *Source) (*RefStatus, error)
	// methods for UnitGroup
	GetUnitGroups(*Empty, DataService_GetUnitGroupsServer) error
	GetUnitGroup(context.Context, *Ref) (*UnitGroupStatus, error)
	PutUnitGroup(context.Context, *UnitGroup) (*RefStatus, error)
	// Get possible providers for the given flow. For products
	// these are processes with that product on the output side
	// and for waste flows processes with that waste flow on the
	// input side. For elementary flows, an empty stream is
	// returned.
	GetProvidersFor(*Ref, DataService_GetProvidersForServer) error
	mustEmbedUnimplementedDataServiceServer()
}

// UnimplementedDataServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDataServiceServer struct {
}

func (UnimplementedDataServiceServer) Delete(context.Context, *Ref) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedDataServiceServer) GetDescriptors(*DescriptorRequest, DataService_GetDescriptorsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetDescriptors not implemented")
}
func (UnimplementedDataServiceServer) GetDescriptor(context.Context, *DescriptorRequest) (*RefStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDescriptor not implemented")
}
func (UnimplementedDataServiceServer) Search(*SearchRequest, DataService_SearchServer) error {
	return status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedDataServiceServer) CreateProductSystem(context.Context, *CreateSystemRequest) (*RefStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProductSystem not implemented")
}
func (UnimplementedDataServiceServer) GetActors(*Empty, DataService_GetActorsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetActors not implemented")
}
func (UnimplementedDataServiceServer) GetActor(context.Context, *Ref) (*ActorStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActor not implemented")
}
func (UnimplementedDataServiceServer) PutActor(context.Context, *Actor) (*RefStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutActor not implemented")
}
func (UnimplementedDataServiceServer) GetCategories(*Empty, DataService_GetCategoriesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetCategories not implemented")
}
func (UnimplementedDataServiceServer) GetCategory(context.Context, *Ref) (*CategoryStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCategory not implemented")
}
func (UnimplementedDataServiceServer) PutCategory(context.Context, *Category) (*RefStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutCategory not implemented")
}
func (UnimplementedDataServiceServer) GetCurrencies(*Empty, DataService_GetCurrenciesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetCurrencies not implemented")
}
func (UnimplementedDataServiceServer) GetCurrency(context.Context, *Ref) (*CurrencyStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrency not implemented")
}
func (UnimplementedDataServiceServer) PutCurrency(context.Context, *Currency) (*RefStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutCurrency not implemented")
}
func (UnimplementedDataServiceServer) GetDQSystems(*Empty, DataService_GetDQSystemsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetDQSystems not implemented")
}
func (UnimplementedDataServiceServer) GetDQSystem(context.Context, *Ref) (*DQSystemStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDQSystem not implemented")
}
func (UnimplementedDataServiceServer) PutDQSystem(context.Context, *DQSystem) (*RefStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutDQSystem not implemented")
}
func (UnimplementedDataServiceServer) GetFlows(*Empty, DataService_GetFlowsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetFlows not implemented")
}
func (UnimplementedDataServiceServer) GetFlow(context.Context, *Ref) (*FlowStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFlow not implemented")
}
func (UnimplementedDataServiceServer) PutFlow(context.Context, *Flow) (*RefStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutFlow not implemented")
}
func (UnimplementedDataServiceServer) GetFlowProperties(*Empty, DataService_GetFlowPropertiesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetFlowProperties not implemented")
}
func (UnimplementedDataServiceServer) GetFlowProperty(context.Context, *Ref) (*FlowPropertyStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFlowProperty not implemented")
}
func (UnimplementedDataServiceServer) PutFlowProperty(context.Context, *FlowProperty) (*RefStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutFlowProperty not implemented")
}
func (UnimplementedDataServiceServer) GetImpactCategories(*Empty, DataService_GetImpactCategoriesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetImpactCategories not implemented")
}
func (UnimplementedDataServiceServer) GetImpactCategory(context.Context, *Ref) (*ImpactCategoryStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImpactCategory not implemented")
}
func (UnimplementedDataServiceServer) PutImpactCategory(context.Context, *ImpactCategory) (*RefStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutImpactCategory not implemented")
}
func (UnimplementedDataServiceServer) GetImpactMethods(*Empty, DataService_GetImpactMethodsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetImpactMethods not implemented")
}
func (UnimplementedDataServiceServer) GetImpactMethod(context.Context, *Ref) (*ImpactMethodStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImpactMethod not implemented")
}
func (UnimplementedDataServiceServer) PutImpactMethod(context.Context, *ImpactMethod) (*RefStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutImpactMethod not implemented")
}
func (UnimplementedDataServiceServer) GetLocations(*Empty, DataService_GetLocationsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetLocations not implemented")
}
func (UnimplementedDataServiceServer) GetLocation(context.Context, *Ref) (*LocationStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLocation not implemented")
}
func (UnimplementedDataServiceServer) PutLocation(context.Context, *Location) (*RefStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutLocation not implemented")
}
func (UnimplementedDataServiceServer) GetParameters(*Empty, DataService_GetParametersServer) error {
	return status.Errorf(codes.Unimplemented, "method GetParameters not implemented")
}
func (UnimplementedDataServiceServer) GetParameter(context.Context, *Ref) (*ParameterStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetParameter not implemented")
}
func (UnimplementedDataServiceServer) PutParameter(context.Context, *Parameter) (*RefStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutParameter not implemented")
}
func (UnimplementedDataServiceServer) GetProcesses(*Empty, DataService_GetProcessesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetProcesses not implemented")
}
func (UnimplementedDataServiceServer) GetProcess(context.Context, *Ref) (*ProcessStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcess not implemented")
}
func (UnimplementedDataServiceServer) PutProcess(context.Context, *Process) (*RefStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutProcess not implemented")
}
func (UnimplementedDataServiceServer) GetProductSystems(*Empty, DataService_GetProductSystemsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetProductSystems not implemented")
}
func (UnimplementedDataServiceServer) GetProductSystem(context.Context, *Ref) (*ProductSystemStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProductSystem not implemented")
}
func (UnimplementedDataServiceServer) PutProductSystem(context.Context, *ProductSystem) (*RefStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutProductSystem not implemented")
}
func (UnimplementedDataServiceServer) GetProjects(*Empty, DataService_GetProjectsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetProjects not implemented")
}
func (UnimplementedDataServiceServer) GetProject(context.Context, *Ref) (*ProjectStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProject not implemented")
}
func (UnimplementedDataServiceServer) PutProject(context.Context, *Project) (*RefStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutProject not implemented")
}
func (UnimplementedDataServiceServer) GetSocialIndicators(*Empty, DataService_GetSocialIndicatorsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetSocialIndicators not implemented")
}
func (UnimplementedDataServiceServer) GetSocialIndicator(context.Context, *Ref) (*SocialIndicatorStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSocialIndicator not implemented")
}
func (UnimplementedDataServiceServer) PutSocialIndicator(context.Context, *SocialIndicator) (*RefStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutSocialIndicator not implemented")
}
func (UnimplementedDataServiceServer) GetSources(*Empty, DataService_GetSourcesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetSources not implemented")
}
func (UnimplementedDataServiceServer) GetSource(context.Context, *Ref) (*SourceStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSource not implemented")
}
func (UnimplementedDataServiceServer) PutSource(context.Context, *Source) (*RefStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutSource not implemented")
}
func (UnimplementedDataServiceServer) GetUnitGroups(*Empty, DataService_GetUnitGroupsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetUnitGroups not implemented")
}
func (UnimplementedDataServiceServer) GetUnitGroup(context.Context, *Ref) (*UnitGroupStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUnitGroup not implemented")
}
func (UnimplementedDataServiceServer) PutUnitGroup(context.Context, *UnitGroup) (*RefStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutUnitGroup not implemented")
}
func (UnimplementedDataServiceServer) GetProvidersFor(*Ref, DataService_GetProvidersForServer) error {
	return status.Errorf(codes.Unimplemented, "method GetProvidersFor not implemented")
}
func (UnimplementedDataServiceServer) mustEmbedUnimplementedDataServiceServer() {}

// UnsafeDataServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DataServiceServer will
// result in compilation errors.
type UnsafeDataServiceServer interface {
	mustEmbedUnimplementedDataServiceServer()
}

func RegisterDataServiceServer(s grpc.ServiceRegistrar, srv DataServiceServer) {
	s.RegisterService(&DataService_ServiceDesc, srv)
}

func _DataService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ref)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).Delete(ctx, req.(*Ref))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetDescriptors_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DescriptorRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).GetDescriptors(m, &dataServiceGetDescriptorsServer{stream})
}

type DataService_GetDescriptorsServer interface {
	Send(*Ref) error
	grpc.ServerStream
}

type dataServiceGetDescriptorsServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetDescriptorsServer) Send(m *Ref) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_GetDescriptor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescriptorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetDescriptor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/GetDescriptor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetDescriptor(ctx, req.(*DescriptorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_Search_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).Search(m, &dataServiceSearchServer{stream})
}

type DataService_SearchServer interface {
	Send(*Ref) error
	grpc.ServerStream
}

type dataServiceSearchServer struct {
	grpc.ServerStream
}

func (x *dataServiceSearchServer) Send(m *Ref) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_CreateProductSystem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSystemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).CreateProductSystem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/CreateProductSystem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).CreateProductSystem(ctx, req.(*CreateSystemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetActors_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).GetActors(m, &dataServiceGetActorsServer{stream})
}

type DataService_GetActorsServer interface {
	Send(*Actor) error
	grpc.ServerStream
}

type dataServiceGetActorsServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetActorsServer) Send(m *Actor) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_GetActor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ref)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetActor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/GetActor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetActor(ctx, req.(*Ref))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_PutActor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Actor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).PutActor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/PutActor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).PutActor(ctx, req.(*Actor))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetCategories_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).GetCategories(m, &dataServiceGetCategoriesServer{stream})
}

type DataService_GetCategoriesServer interface {
	Send(*Category) error
	grpc.ServerStream
}

type dataServiceGetCategoriesServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetCategoriesServer) Send(m *Category) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_GetCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ref)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/GetCategory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetCategory(ctx, req.(*Ref))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_PutCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Category)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).PutCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/PutCategory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).PutCategory(ctx, req.(*Category))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetCurrencies_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).GetCurrencies(m, &dataServiceGetCurrenciesServer{stream})
}

type DataService_GetCurrenciesServer interface {
	Send(*Currency) error
	grpc.ServerStream
}

type dataServiceGetCurrenciesServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetCurrenciesServer) Send(m *Currency) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_GetCurrency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ref)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetCurrency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/GetCurrency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetCurrency(ctx, req.(*Ref))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_PutCurrency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Currency)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).PutCurrency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/PutCurrency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).PutCurrency(ctx, req.(*Currency))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetDQSystems_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).GetDQSystems(m, &dataServiceGetDQSystemsServer{stream})
}

type DataService_GetDQSystemsServer interface {
	Send(*DQSystem) error
	grpc.ServerStream
}

type dataServiceGetDQSystemsServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetDQSystemsServer) Send(m *DQSystem) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_GetDQSystem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ref)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetDQSystem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/GetDQSystem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetDQSystem(ctx, req.(*Ref))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_PutDQSystem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DQSystem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).PutDQSystem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/PutDQSystem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).PutDQSystem(ctx, req.(*DQSystem))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetFlows_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).GetFlows(m, &dataServiceGetFlowsServer{stream})
}

type DataService_GetFlowsServer interface {
	Send(*Flow) error
	grpc.ServerStream
}

type dataServiceGetFlowsServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetFlowsServer) Send(m *Flow) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_GetFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ref)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/GetFlow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetFlow(ctx, req.(*Ref))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_PutFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Flow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).PutFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/PutFlow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).PutFlow(ctx, req.(*Flow))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetFlowProperties_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).GetFlowProperties(m, &dataServiceGetFlowPropertiesServer{stream})
}

type DataService_GetFlowPropertiesServer interface {
	Send(*FlowProperty) error
	grpc.ServerStream
}

type dataServiceGetFlowPropertiesServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetFlowPropertiesServer) Send(m *FlowProperty) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_GetFlowProperty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ref)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetFlowProperty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/GetFlowProperty",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetFlowProperty(ctx, req.(*Ref))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_PutFlowProperty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowProperty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).PutFlowProperty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/PutFlowProperty",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).PutFlowProperty(ctx, req.(*FlowProperty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetImpactCategories_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).GetImpactCategories(m, &dataServiceGetImpactCategoriesServer{stream})
}

type DataService_GetImpactCategoriesServer interface {
	Send(*ImpactCategory) error
	grpc.ServerStream
}

type dataServiceGetImpactCategoriesServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetImpactCategoriesServer) Send(m *ImpactCategory) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_GetImpactCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ref)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetImpactCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/GetImpactCategory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetImpactCategory(ctx, req.(*Ref))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_PutImpactCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImpactCategory)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).PutImpactCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/PutImpactCategory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).PutImpactCategory(ctx, req.(*ImpactCategory))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetImpactMethods_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).GetImpactMethods(m, &dataServiceGetImpactMethodsServer{stream})
}

type DataService_GetImpactMethodsServer interface {
	Send(*ImpactMethod) error
	grpc.ServerStream
}

type dataServiceGetImpactMethodsServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetImpactMethodsServer) Send(m *ImpactMethod) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_GetImpactMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ref)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetImpactMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/GetImpactMethod",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetImpactMethod(ctx, req.(*Ref))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_PutImpactMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImpactMethod)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).PutImpactMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/PutImpactMethod",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).PutImpactMethod(ctx, req.(*ImpactMethod))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetLocations_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).GetLocations(m, &dataServiceGetLocationsServer{stream})
}

type DataService_GetLocationsServer interface {
	Send(*Location) error
	grpc.ServerStream
}

type dataServiceGetLocationsServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetLocationsServer) Send(m *Location) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_GetLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ref)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/GetLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetLocation(ctx, req.(*Ref))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_PutLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Location)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).PutLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/PutLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).PutLocation(ctx, req.(*Location))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetParameters_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).GetParameters(m, &dataServiceGetParametersServer{stream})
}

type DataService_GetParametersServer interface {
	Send(*Parameter) error
	grpc.ServerStream
}

type dataServiceGetParametersServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetParametersServer) Send(m *Parameter) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_GetParameter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ref)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetParameter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/GetParameter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetParameter(ctx, req.(*Ref))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_PutParameter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Parameter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).PutParameter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/PutParameter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).PutParameter(ctx, req.(*Parameter))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetProcesses_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).GetProcesses(m, &dataServiceGetProcessesServer{stream})
}

type DataService_GetProcessesServer interface {
	Send(*Process) error
	grpc.ServerStream
}

type dataServiceGetProcessesServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetProcessesServer) Send(m *Process) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_GetProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ref)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/GetProcess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetProcess(ctx, req.(*Ref))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_PutProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Process)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).PutProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/PutProcess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).PutProcess(ctx, req.(*Process))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetProductSystems_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).GetProductSystems(m, &dataServiceGetProductSystemsServer{stream})
}

type DataService_GetProductSystemsServer interface {
	Send(*ProductSystem) error
	grpc.ServerStream
}

type dataServiceGetProductSystemsServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetProductSystemsServer) Send(m *ProductSystem) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_GetProductSystem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ref)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetProductSystem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/GetProductSystem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetProductSystem(ctx, req.(*Ref))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_PutProductSystem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductSystem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).PutProductSystem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/PutProductSystem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).PutProductSystem(ctx, req.(*ProductSystem))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetProjects_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).GetProjects(m, &dataServiceGetProjectsServer{stream})
}

type DataService_GetProjectsServer interface {
	Send(*Project) error
	grpc.ServerStream
}

type dataServiceGetProjectsServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetProjectsServer) Send(m *Project) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_GetProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ref)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/GetProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetProject(ctx, req.(*Ref))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_PutProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Project)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).PutProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/PutProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).PutProject(ctx, req.(*Project))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetSocialIndicators_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).GetSocialIndicators(m, &dataServiceGetSocialIndicatorsServer{stream})
}

type DataService_GetSocialIndicatorsServer interface {
	Send(*SocialIndicator) error
	grpc.ServerStream
}

type dataServiceGetSocialIndicatorsServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetSocialIndicatorsServer) Send(m *SocialIndicator) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_GetSocialIndicator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ref)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetSocialIndicator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/GetSocialIndicator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetSocialIndicator(ctx, req.(*Ref))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_PutSocialIndicator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SocialIndicator)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).PutSocialIndicator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/PutSocialIndicator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).PutSocialIndicator(ctx, req.(*SocialIndicator))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetSources_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).GetSources(m, &dataServiceGetSourcesServer{stream})
}

type DataService_GetSourcesServer interface {
	Send(*Source) error
	grpc.ServerStream
}

type dataServiceGetSourcesServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetSourcesServer) Send(m *Source) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_GetSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ref)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/GetSource",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetSource(ctx, req.(*Ref))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_PutSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Source)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).PutSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/PutSource",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).PutSource(ctx, req.(*Source))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetUnitGroups_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).GetUnitGroups(m, &dataServiceGetUnitGroupsServer{stream})
}

type DataService_GetUnitGroupsServer interface {
	Send(*UnitGroup) error
	grpc.ServerStream
}

type dataServiceGetUnitGroupsServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetUnitGroupsServer) Send(m *UnitGroup) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_GetUnitGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ref)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetUnitGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/GetUnitGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetUnitGroup(ctx, req.(*Ref))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_PutUnitGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnitGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).PutUnitGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.DataService/PutUnitGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).PutUnitGroup(ctx, req.(*UnitGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetProvidersFor_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Ref)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).GetProvidersFor(m, &dataServiceGetProvidersForServer{stream})
}

type DataService_GetProvidersForServer interface {
	Send(*Ref) error
	grpc.ServerStream
}

type dataServiceGetProvidersForServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetProvidersForServer) Send(m *Ref) error {
	return x.ServerStream.SendMsg(m)
}

// DataService_ServiceDesc is the grpc.ServiceDesc for DataService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DataService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "protolca.services.DataService",
	HandlerType: (*DataServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _DataService_Delete_Handler,
		},
		{
			MethodName: "GetDescriptor",
			Handler:    _DataService_GetDescriptor_Handler,
		},
		{
			MethodName: "CreateProductSystem",
			Handler:    _DataService_CreateProductSystem_Handler,
		},
		{
			MethodName: "GetActor",
			Handler:    _DataService_GetActor_Handler,
		},
		{
			MethodName: "PutActor",
			Handler:    _DataService_PutActor_Handler,
		},
		{
			MethodName: "GetCategory",
			Handler:    _DataService_GetCategory_Handler,
		},
		{
			MethodName: "PutCategory",
			Handler:    _DataService_PutCategory_Handler,
		},
		{
			MethodName: "GetCurrency",
			Handler:    _DataService_GetCurrency_Handler,
		},
		{
			MethodName: "PutCurrency",
			Handler:    _DataService_PutCurrency_Handler,
		},
		{
			MethodName: "GetDQSystem",
			Handler:    _DataService_GetDQSystem_Handler,
		},
		{
			MethodName: "PutDQSystem",
			Handler:    _DataService_PutDQSystem_Handler,
		},
		{
			MethodName: "GetFlow",
			Handler:    _DataService_GetFlow_Handler,
		},
		{
			MethodName: "PutFlow",
			Handler:    _DataService_PutFlow_Handler,
		},
		{
			MethodName: "GetFlowProperty",
			Handler:    _DataService_GetFlowProperty_Handler,
		},
		{
			MethodName: "PutFlowProperty",
			Handler:    _DataService_PutFlowProperty_Handler,
		},
		{
			MethodName: "GetImpactCategory",
			Handler:    _DataService_GetImpactCategory_Handler,
		},
		{
			MethodName: "PutImpactCategory",
			Handler:    _DataService_PutImpactCategory_Handler,
		},
		{
			MethodName: "GetImpactMethod",
			Handler:    _DataService_GetImpactMethod_Handler,
		},
		{
			MethodName: "PutImpactMethod",
			Handler:    _DataService_PutImpactMethod_Handler,
		},
		{
			MethodName: "GetLocation",
			Handler:    _DataService_GetLocation_Handler,
		},
		{
			MethodName: "PutLocation",
			Handler:    _DataService_PutLocation_Handler,
		},
		{
			MethodName: "GetParameter",
			Handler:    _DataService_GetParameter_Handler,
		},
		{
			MethodName: "PutParameter",
			Handler:    _DataService_PutParameter_Handler,
		},
		{
			MethodName: "GetProcess",
			Handler:    _DataService_GetProcess_Handler,
		},
		{
			MethodName: "PutProcess",
			Handler:    _DataService_PutProcess_Handler,
		},
		{
			MethodName: "GetProductSystem",
			Handler:    _DataService_GetProductSystem_Handler,
		},
		{
			MethodName: "PutProductSystem",
			Handler:    _DataService_PutProductSystem_Handler,
		},
		{
			MethodName: "GetProject",
			Handler:    _DataService_GetProject_Handler,
		},
		{
			MethodName: "PutProject",
			Handler:    _DataService_PutProject_Handler,
		},
		{
			MethodName: "GetSocialIndicator",
			Handler:    _DataService_GetSocialIndicator_Handler,
		},
		{
			MethodName: "PutSocialIndicator",
			Handler:    _DataService_PutSocialIndicator_Handler,
		},
		{
			MethodName: "GetSource",
			Handler:    _DataService_GetSource_Handler,
		},
		{
			MethodName: "PutSource",
			Handler:    _DataService_PutSource_Handler,
		},
		{
			MethodName: "GetUnitGroup",
			Handler:    _DataService_GetUnitGroup_Handler,
		},
		{
			MethodName: "PutUnitGroup",
			Handler:    _DataService_PutUnitGroup_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetDescriptors",
			Handler:       _DataService_GetDescriptors_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Search",
			Handler:       _DataService_Search_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetActors",
			Handler:       _DataService_GetActors_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetCategories",
			Handler:       _DataService_GetCategories_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetCurrencies",
			Handler:       _DataService_GetCurrencies_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetDQSystems",
			Handler:       _DataService_GetDQSystems_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetFlows",
			Handler:       _DataService_GetFlows_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetFlowProperties",
			Handler:       _DataService_GetFlowProperties_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetImpactCategories",
			Handler:       _DataService_GetImpactCategories_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetImpactMethods",
			Handler:       _DataService_GetImpactMethods_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetLocations",
			Handler:       _DataService_GetLocations_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetParameters",
			Handler:       _DataService_GetParameters_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetProcesses",
			Handler:       _DataService_GetProcesses_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetProductSystems",
			Handler:       _DataService_GetProductSystems_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetProjects",
			Handler:       _DataService_GetProjects_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetSocialIndicators",
			Handler:       _DataService_GetSocialIndicators_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetSources",
			Handler:       _DataService_GetSources_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetUnitGroups",
			Handler:       _DataService_GetUnitGroups_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetProvidersFor",
			Handler:       _DataService_GetProvidersFor_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "services.proto",
}

// FlowMapServiceClient is the client API for FlowMapService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FlowMapServiceClient interface {
	// Delete the flow map with the given name.
	Delete(ctx context.Context, in *FlowMapInfo, opts ...grpc.CallOption) (*Status, error)
	// Get the flow map with the given name form the
	// database.
	Get(ctx context.Context, in *FlowMapInfo, opts ...grpc.CallOption) (*FlowMapStatus, error)
	// Get the information (basically just the names) of all
	// flow maps that are available in the database.
	GetAll(ctx context.Context, in *Empty, opts ...grpc.CallOption) (FlowMapService_GetAllClient, error)
	// Inserts the given flow map into the database. It overwrites
	// an existing flow map if there is a flow map with the same
	// name already available in the database.
	Put(ctx context.Context, in *FlowMap, opts ...grpc.CallOption) (*Status, error)
}

type flowMapServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFlowMapServiceClient(cc grpc.ClientConnInterface) FlowMapServiceClient {
	return &flowMapServiceClient{cc}
}

func (c *flowMapServiceClient) Delete(ctx context.Context, in *FlowMapInfo, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/protolca.services.FlowMapService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowMapServiceClient) Get(ctx context.Context, in *FlowMapInfo, opts ...grpc.CallOption) (*FlowMapStatus, error) {
	out := new(FlowMapStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.FlowMapService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowMapServiceClient) GetAll(ctx context.Context, in *Empty, opts ...grpc.CallOption) (FlowMapService_GetAllClient, error) {
	stream, err := c.cc.NewStream(ctx, &FlowMapService_ServiceDesc.Streams[0], "/protolca.services.FlowMapService/GetAll", opts...)
	if err != nil {
		return nil, err
	}
	x := &flowMapServiceGetAllClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FlowMapService_GetAllClient interface {
	Recv() (*FlowMapInfo, error)
	grpc.ClientStream
}

type flowMapServiceGetAllClient struct {
	grpc.ClientStream
}

func (x *flowMapServiceGetAllClient) Recv() (*FlowMapInfo, error) {
	m := new(FlowMapInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flowMapServiceClient) Put(ctx context.Context, in *FlowMap, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/protolca.services.FlowMapService/Put", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FlowMapServiceServer is the server API for FlowMapService service.
// All implementations must embed UnimplementedFlowMapServiceServer
// for forward compatibility
type FlowMapServiceServer interface {
	// Delete the flow map with the given name.
	Delete(context.Context, *FlowMapInfo) (*Status, error)
	// Get the flow map with the given name form the
	// database.
	Get(context.Context, *FlowMapInfo) (*FlowMapStatus, error)
	// Get the information (basically just the names) of all
	// flow maps that are available in the database.
	GetAll(*Empty, FlowMapService_GetAllServer) error
	// Inserts the given flow map into the database. It overwrites
	// an existing flow map if there is a flow map with the same
	// name already available in the database.
	Put(context.Context, *FlowMap) (*Status, error)
	mustEmbedUnimplementedFlowMapServiceServer()
}

// UnimplementedFlowMapServiceServer must be embedded to have forward compatible implementations.
type UnimplementedFlowMapServiceServer struct {
}

func (UnimplementedFlowMapServiceServer) Delete(context.Context, *FlowMapInfo) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedFlowMapServiceServer) Get(context.Context, *FlowMapInfo) (*FlowMapStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedFlowMapServiceServer) GetAll(*Empty, FlowMapService_GetAllServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (UnimplementedFlowMapServiceServer) Put(context.Context, *FlowMap) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (UnimplementedFlowMapServiceServer) mustEmbedUnimplementedFlowMapServiceServer() {}

// UnsafeFlowMapServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FlowMapServiceServer will
// result in compilation errors.
type UnsafeFlowMapServiceServer interface {
	mustEmbedUnimplementedFlowMapServiceServer()
}

func RegisterFlowMapServiceServer(s grpc.ServiceRegistrar, srv FlowMapServiceServer) {
	s.RegisterService(&FlowMapService_ServiceDesc, srv)
}

func _FlowMapService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowMapInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowMapServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.FlowMapService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowMapServiceServer).Delete(ctx, req.(*FlowMapInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowMapService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowMapInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowMapServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.FlowMapService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowMapServiceServer).Get(ctx, req.(*FlowMapInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowMapService_GetAll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlowMapServiceServer).GetAll(m, &flowMapServiceGetAllServer{stream})
}

type FlowMapService_GetAllServer interface {
	Send(*FlowMapInfo) error
	grpc.ServerStream
}

type flowMapServiceGetAllServer struct {
	grpc.ServerStream
}

func (x *flowMapServiceGetAllServer) Send(m *FlowMapInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _FlowMapService_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowMap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowMapServiceServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.FlowMapService/Put",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowMapServiceServer).Put(ctx, req.(*FlowMap))
	}
	return interceptor(ctx, in, info, handler)
}

// FlowMapService_ServiceDesc is the grpc.ServiceDesc for FlowMapService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FlowMapService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "protolca.services.FlowMapService",
	HandlerType: (*FlowMapServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _FlowMapService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _FlowMapService_Get_Handler,
		},
		{
			MethodName: "Put",
			Handler:    _FlowMapService_Put_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAll",
			Handler:       _FlowMapService_GetAll_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "services.proto",
}

// ResultServiceClient is the client API for ResultService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ResultServiceClient interface {
	// Calculates a result for the given calculation setup.
	Calculate(ctx context.Context, in *CalculationSetup, opts ...grpc.CallOption) (*ResultStatus, error)
	// Get the inventory of the given result.
	GetInventory(ctx context.Context, in *Result, opts ...grpc.CallOption) (ResultService_GetInventoryClient, error)
	// Get the total impact assessment result of the given result.
	GetImpacts(ctx context.Context, in *Result, opts ...grpc.CallOption) (ResultService_GetImpactsClient, error)
	// Disposes the given result on the server side.
	Dispose(ctx context.Context, in *Result, opts ...grpc.CallOption) (*Status, error)
}

type resultServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewResultServiceClient(cc grpc.ClientConnInterface) ResultServiceClient {
	return &resultServiceClient{cc}
}

func (c *resultServiceClient) Calculate(ctx context.Context, in *CalculationSetup, opts ...grpc.CallOption) (*ResultStatus, error) {
	out := new(ResultStatus)
	err := c.cc.Invoke(ctx, "/protolca.services.ResultService/Calculate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resultServiceClient) GetInventory(ctx context.Context, in *Result, opts ...grpc.CallOption) (ResultService_GetInventoryClient, error) {
	stream, err := c.cc.NewStream(ctx, &ResultService_ServiceDesc.Streams[0], "/protolca.services.ResultService/GetInventory", opts...)
	if err != nil {
		return nil, err
	}
	x := &resultServiceGetInventoryClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ResultService_GetInventoryClient interface {
	Recv() (*FlowResult, error)
	grpc.ClientStream
}

type resultServiceGetInventoryClient struct {
	grpc.ClientStream
}

func (x *resultServiceGetInventoryClient) Recv() (*FlowResult, error) {
	m := new(FlowResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *resultServiceClient) GetImpacts(ctx context.Context, in *Result, opts ...grpc.CallOption) (ResultService_GetImpactsClient, error) {
	stream, err := c.cc.NewStream(ctx, &ResultService_ServiceDesc.Streams[1], "/protolca.services.ResultService/GetImpacts", opts...)
	if err != nil {
		return nil, err
	}
	x := &resultServiceGetImpactsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ResultService_GetImpactsClient interface {
	Recv() (*ImpactResult, error)
	grpc.ClientStream
}

type resultServiceGetImpactsClient struct {
	grpc.ClientStream
}

func (x *resultServiceGetImpactsClient) Recv() (*ImpactResult, error) {
	m := new(ImpactResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *resultServiceClient) Dispose(ctx context.Context, in *Result, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/protolca.services.ResultService/Dispose", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ResultServiceServer is the server API for ResultService service.
// All implementations must embed UnimplementedResultServiceServer
// for forward compatibility
type ResultServiceServer interface {
	// Calculates a result for the given calculation setup.
	Calculate(context.Context, *CalculationSetup) (*ResultStatus, error)
	// Get the inventory of the given result.
	GetInventory(*Result, ResultService_GetInventoryServer) error
	// Get the total impact assessment result of the given result.
	GetImpacts(*Result, ResultService_GetImpactsServer) error
	// Disposes the given result on the server side.
	Dispose(context.Context, *Result) (*Status, error)
	mustEmbedUnimplementedResultServiceServer()
}

// UnimplementedResultServiceServer must be embedded to have forward compatible implementations.
type UnimplementedResultServiceServer struct {
}

func (UnimplementedResultServiceServer) Calculate(context.Context, *CalculationSetup) (*ResultStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Calculate not implemented")
}
func (UnimplementedResultServiceServer) GetInventory(*Result, ResultService_GetInventoryServer) error {
	return status.Errorf(codes.Unimplemented, "method GetInventory not implemented")
}
func (UnimplementedResultServiceServer) GetImpacts(*Result, ResultService_GetImpactsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetImpacts not implemented")
}
func (UnimplementedResultServiceServer) Dispose(context.Context, *Result) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Dispose not implemented")
}
func (UnimplementedResultServiceServer) mustEmbedUnimplementedResultServiceServer() {}

// UnsafeResultServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ResultServiceServer will
// result in compilation errors.
type UnsafeResultServiceServer interface {
	mustEmbedUnimplementedResultServiceServer()
}

func RegisterResultServiceServer(s grpc.ServiceRegistrar, srv ResultServiceServer) {
	s.RegisterService(&ResultService_ServiceDesc, srv)
}

func _ResultService_Calculate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CalculationSetup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResultServiceServer).Calculate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.ResultService/Calculate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResultServiceServer).Calculate(ctx, req.(*CalculationSetup))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResultService_GetInventory_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Result)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ResultServiceServer).GetInventory(m, &resultServiceGetInventoryServer{stream})
}

type ResultService_GetInventoryServer interface {
	Send(*FlowResult) error
	grpc.ServerStream
}

type resultServiceGetInventoryServer struct {
	grpc.ServerStream
}

func (x *resultServiceGetInventoryServer) Send(m *FlowResult) error {
	return x.ServerStream.SendMsg(m)
}

func _ResultService_GetImpacts_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Result)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ResultServiceServer).GetImpacts(m, &resultServiceGetImpactsServer{stream})
}

type ResultService_GetImpactsServer interface {
	Send(*ImpactResult) error
	grpc.ServerStream
}

type resultServiceGetImpactsServer struct {
	grpc.ServerStream
}

func (x *resultServiceGetImpactsServer) Send(m *ImpactResult) error {
	return x.ServerStream.SendMsg(m)
}

func _ResultService_Dispose_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Result)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResultServiceServer).Dispose(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.ResultService/Dispose",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResultServiceServer).Dispose(ctx, req.(*Result))
	}
	return interceptor(ctx, in, info, handler)
}

// ResultService_ServiceDesc is the grpc.ServiceDesc for ResultService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ResultService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "protolca.services.ResultService",
	HandlerType: (*ResultServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Calculate",
			Handler:    _ResultService_Calculate_Handler,
		},
		{
			MethodName: "Dispose",
			Handler:    _ResultService_Dispose_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetInventory",
			Handler:       _ResultService_GetInventory_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetImpacts",
			Handler:       _ResultService_GetImpacts_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "services.proto",
}
