// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package protolca

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ResultServiceClient is the client API for ResultService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ResultServiceClient interface {
	// Calculates a result for the given calculation setup.
	Calculate(ctx context.Context, in *CalculationSetup, opts ...grpc.CallOption) (*Result, error)
	// Get all technosphere flows of the underlying product system of the given
	// result.
	GetTechFlows(ctx context.Context, in *Result, opts ...grpc.CallOption) (ResultService_GetTechFlowsClient, error)
	// Get the environmental flows of the given result.
	GetEnviFlows(ctx context.Context, in *Result, opts ...grpc.CallOption) (ResultService_GetEnviFlowsClient, error)
	// Get the impact categories of the given result.
	GetImpactCategories(ctx context.Context, in *Result, opts ...grpc.CallOption) (ResultService_GetImpactCategoriesClient, error)
	// Get the inventory of the given result.
	GetTotalInventory(ctx context.Context, in *Result, opts ...grpc.CallOption) (ResultService_GetTotalInventoryClient, error)
	// Get the total impact assessment result of the given result.
	GetTotalImpacts(ctx context.Context, in *Result, opts ...grpc.CallOption) (ResultService_GetTotalImpactsClient, error)
	// Get the direct contribution of a TechFlow to a flow, impact, or cost
	// result. 'Direct' means that this is only the contribution that is
	// directly associated with the production of a product or treatment of
	// a waste flow excluding contributions of upstream and downstream processes.
	GetDirectContribution(ctx context.Context, in *TechFlowContributionRequest, opts ...grpc.CallOption) (*ResultValue, error)
	GetTotalContribution(ctx context.Context, in *TechFlowContributionRequest, opts ...grpc.CallOption) (*ResultValue, error)
	GetTotalContributionOfOne(ctx context.Context, in *TechFlowContributionRequest, opts ...grpc.CallOption) (*ResultValue, error)
	// Get the used impact factors of a result. The request can be for:
	//
	// * an indicator: returns the non-zero factors of that indicator
	// * a flow: returns the factors of that flow for all indicators (including
	//   zero values)
	// * an indicator and flow: returns the factor for that flow which may be zero
	//
	// Nothing is returned if no indicator and flow is given or if the result does
	// not have an impact assessment result.
	GetImpactFactors(ctx context.Context, in *ImpactFactorRequest, opts ...grpc.CallOption) (ResultService_GetImpactFactorsClient, error)
	// Disposes the given result on the server side.
	Dispose(ctx context.Context, in *Result, opts ...grpc.CallOption) (*empty.Empty, error)
}

type resultServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewResultServiceClient(cc grpc.ClientConnInterface) ResultServiceClient {
	return &resultServiceClient{cc}
}

func (c *resultServiceClient) Calculate(ctx context.Context, in *CalculationSetup, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/protolca.services.ResultService/Calculate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resultServiceClient) GetTechFlows(ctx context.Context, in *Result, opts ...grpc.CallOption) (ResultService_GetTechFlowsClient, error) {
	stream, err := c.cc.NewStream(ctx, &ResultService_ServiceDesc.Streams[0], "/protolca.services.ResultService/GetTechFlows", opts...)
	if err != nil {
		return nil, err
	}
	x := &resultServiceGetTechFlowsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ResultService_GetTechFlowsClient interface {
	Recv() (*TechFlow, error)
	grpc.ClientStream
}

type resultServiceGetTechFlowsClient struct {
	grpc.ClientStream
}

func (x *resultServiceGetTechFlowsClient) Recv() (*TechFlow, error) {
	m := new(TechFlow)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *resultServiceClient) GetEnviFlows(ctx context.Context, in *Result, opts ...grpc.CallOption) (ResultService_GetEnviFlowsClient, error) {
	stream, err := c.cc.NewStream(ctx, &ResultService_ServiceDesc.Streams[1], "/protolca.services.ResultService/GetEnviFlows", opts...)
	if err != nil {
		return nil, err
	}
	x := &resultServiceGetEnviFlowsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ResultService_GetEnviFlowsClient interface {
	Recv() (*EnviFlow, error)
	grpc.ClientStream
}

type resultServiceGetEnviFlowsClient struct {
	grpc.ClientStream
}

func (x *resultServiceGetEnviFlowsClient) Recv() (*EnviFlow, error) {
	m := new(EnviFlow)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *resultServiceClient) GetImpactCategories(ctx context.Context, in *Result, opts ...grpc.CallOption) (ResultService_GetImpactCategoriesClient, error) {
	stream, err := c.cc.NewStream(ctx, &ResultService_ServiceDesc.Streams[2], "/protolca.services.ResultService/GetImpactCategories", opts...)
	if err != nil {
		return nil, err
	}
	x := &resultServiceGetImpactCategoriesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ResultService_GetImpactCategoriesClient interface {
	Recv() (*Ref, error)
	grpc.ClientStream
}

type resultServiceGetImpactCategoriesClient struct {
	grpc.ClientStream
}

func (x *resultServiceGetImpactCategoriesClient) Recv() (*Ref, error) {
	m := new(Ref)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *resultServiceClient) GetTotalInventory(ctx context.Context, in *Result, opts ...grpc.CallOption) (ResultService_GetTotalInventoryClient, error) {
	stream, err := c.cc.NewStream(ctx, &ResultService_ServiceDesc.Streams[3], "/protolca.services.ResultService/GetTotalInventory", opts...)
	if err != nil {
		return nil, err
	}
	x := &resultServiceGetTotalInventoryClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ResultService_GetTotalInventoryClient interface {
	Recv() (*ResultValue, error)
	grpc.ClientStream
}

type resultServiceGetTotalInventoryClient struct {
	grpc.ClientStream
}

func (x *resultServiceGetTotalInventoryClient) Recv() (*ResultValue, error) {
	m := new(ResultValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *resultServiceClient) GetTotalImpacts(ctx context.Context, in *Result, opts ...grpc.CallOption) (ResultService_GetTotalImpactsClient, error) {
	stream, err := c.cc.NewStream(ctx, &ResultService_ServiceDesc.Streams[4], "/protolca.services.ResultService/GetTotalImpacts", opts...)
	if err != nil {
		return nil, err
	}
	x := &resultServiceGetTotalImpactsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ResultService_GetTotalImpactsClient interface {
	Recv() (*ResultValue, error)
	grpc.ClientStream
}

type resultServiceGetTotalImpactsClient struct {
	grpc.ClientStream
}

func (x *resultServiceGetTotalImpactsClient) Recv() (*ResultValue, error) {
	m := new(ResultValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *resultServiceClient) GetDirectContribution(ctx context.Context, in *TechFlowContributionRequest, opts ...grpc.CallOption) (*ResultValue, error) {
	out := new(ResultValue)
	err := c.cc.Invoke(ctx, "/protolca.services.ResultService/GetDirectContribution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resultServiceClient) GetTotalContribution(ctx context.Context, in *TechFlowContributionRequest, opts ...grpc.CallOption) (*ResultValue, error) {
	out := new(ResultValue)
	err := c.cc.Invoke(ctx, "/protolca.services.ResultService/GetTotalContribution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resultServiceClient) GetTotalContributionOfOne(ctx context.Context, in *TechFlowContributionRequest, opts ...grpc.CallOption) (*ResultValue, error) {
	out := new(ResultValue)
	err := c.cc.Invoke(ctx, "/protolca.services.ResultService/GetTotalContributionOfOne", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resultServiceClient) GetImpactFactors(ctx context.Context, in *ImpactFactorRequest, opts ...grpc.CallOption) (ResultService_GetImpactFactorsClient, error) {
	stream, err := c.cc.NewStream(ctx, &ResultService_ServiceDesc.Streams[5], "/protolca.services.ResultService/GetImpactFactors", opts...)
	if err != nil {
		return nil, err
	}
	x := &resultServiceGetImpactFactorsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ResultService_GetImpactFactorsClient interface {
	Recv() (*ImpactFactorResponse, error)
	grpc.ClientStream
}

type resultServiceGetImpactFactorsClient struct {
	grpc.ClientStream
}

func (x *resultServiceGetImpactFactorsClient) Recv() (*ImpactFactorResponse, error) {
	m := new(ImpactFactorResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *resultServiceClient) Dispose(ctx context.Context, in *Result, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/protolca.services.ResultService/Dispose", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ResultServiceServer is the server API for ResultService service.
// All implementations must embed UnimplementedResultServiceServer
// for forward compatibility
type ResultServiceServer interface {
	// Calculates a result for the given calculation setup.
	Calculate(context.Context, *CalculationSetup) (*Result, error)
	// Get all technosphere flows of the underlying product system of the given
	// result.
	GetTechFlows(*Result, ResultService_GetTechFlowsServer) error
	// Get the environmental flows of the given result.
	GetEnviFlows(*Result, ResultService_GetEnviFlowsServer) error
	// Get the impact categories of the given result.
	GetImpactCategories(*Result, ResultService_GetImpactCategoriesServer) error
	// Get the inventory of the given result.
	GetTotalInventory(*Result, ResultService_GetTotalInventoryServer) error
	// Get the total impact assessment result of the given result.
	GetTotalImpacts(*Result, ResultService_GetTotalImpactsServer) error
	// Get the direct contribution of a TechFlow to a flow, impact, or cost
	// result. 'Direct' means that this is only the contribution that is
	// directly associated with the production of a product or treatment of
	// a waste flow excluding contributions of upstream and downstream processes.
	GetDirectContribution(context.Context, *TechFlowContributionRequest) (*ResultValue, error)
	GetTotalContribution(context.Context, *TechFlowContributionRequest) (*ResultValue, error)
	GetTotalContributionOfOne(context.Context, *TechFlowContributionRequest) (*ResultValue, error)
	// Get the used impact factors of a result. The request can be for:
	//
	// * an indicator: returns the non-zero factors of that indicator
	// * a flow: returns the factors of that flow for all indicators (including
	//   zero values)
	// * an indicator and flow: returns the factor for that flow which may be zero
	//
	// Nothing is returned if no indicator and flow is given or if the result does
	// not have an impact assessment result.
	GetImpactFactors(*ImpactFactorRequest, ResultService_GetImpactFactorsServer) error
	// Disposes the given result on the server side.
	Dispose(context.Context, *Result) (*empty.Empty, error)
	mustEmbedUnimplementedResultServiceServer()
}

// UnimplementedResultServiceServer must be embedded to have forward compatible implementations.
type UnimplementedResultServiceServer struct {
}

func (UnimplementedResultServiceServer) Calculate(context.Context, *CalculationSetup) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Calculate not implemented")
}
func (UnimplementedResultServiceServer) GetTechFlows(*Result, ResultService_GetTechFlowsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetTechFlows not implemented")
}
func (UnimplementedResultServiceServer) GetEnviFlows(*Result, ResultService_GetEnviFlowsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetEnviFlows not implemented")
}
func (UnimplementedResultServiceServer) GetImpactCategories(*Result, ResultService_GetImpactCategoriesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetImpactCategories not implemented")
}
func (UnimplementedResultServiceServer) GetTotalInventory(*Result, ResultService_GetTotalInventoryServer) error {
	return status.Errorf(codes.Unimplemented, "method GetTotalInventory not implemented")
}
func (UnimplementedResultServiceServer) GetTotalImpacts(*Result, ResultService_GetTotalImpactsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetTotalImpacts not implemented")
}
func (UnimplementedResultServiceServer) GetDirectContribution(context.Context, *TechFlowContributionRequest) (*ResultValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDirectContribution not implemented")
}
func (UnimplementedResultServiceServer) GetTotalContribution(context.Context, *TechFlowContributionRequest) (*ResultValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTotalContribution not implemented")
}
func (UnimplementedResultServiceServer) GetTotalContributionOfOne(context.Context, *TechFlowContributionRequest) (*ResultValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTotalContributionOfOne not implemented")
}
func (UnimplementedResultServiceServer) GetImpactFactors(*ImpactFactorRequest, ResultService_GetImpactFactorsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetImpactFactors not implemented")
}
func (UnimplementedResultServiceServer) Dispose(context.Context, *Result) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Dispose not implemented")
}
func (UnimplementedResultServiceServer) mustEmbedUnimplementedResultServiceServer() {}

// UnsafeResultServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ResultServiceServer will
// result in compilation errors.
type UnsafeResultServiceServer interface {
	mustEmbedUnimplementedResultServiceServer()
}

func RegisterResultServiceServer(s grpc.ServiceRegistrar, srv ResultServiceServer) {
	s.RegisterService(&ResultService_ServiceDesc, srv)
}

func _ResultService_Calculate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CalculationSetup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResultServiceServer).Calculate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.ResultService/Calculate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResultServiceServer).Calculate(ctx, req.(*CalculationSetup))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResultService_GetTechFlows_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Result)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ResultServiceServer).GetTechFlows(m, &resultServiceGetTechFlowsServer{stream})
}

type ResultService_GetTechFlowsServer interface {
	Send(*TechFlow) error
	grpc.ServerStream
}

type resultServiceGetTechFlowsServer struct {
	grpc.ServerStream
}

func (x *resultServiceGetTechFlowsServer) Send(m *TechFlow) error {
	return x.ServerStream.SendMsg(m)
}

func _ResultService_GetEnviFlows_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Result)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ResultServiceServer).GetEnviFlows(m, &resultServiceGetEnviFlowsServer{stream})
}

type ResultService_GetEnviFlowsServer interface {
	Send(*EnviFlow) error
	grpc.ServerStream
}

type resultServiceGetEnviFlowsServer struct {
	grpc.ServerStream
}

func (x *resultServiceGetEnviFlowsServer) Send(m *EnviFlow) error {
	return x.ServerStream.SendMsg(m)
}

func _ResultService_GetImpactCategories_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Result)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ResultServiceServer).GetImpactCategories(m, &resultServiceGetImpactCategoriesServer{stream})
}

type ResultService_GetImpactCategoriesServer interface {
	Send(*Ref) error
	grpc.ServerStream
}

type resultServiceGetImpactCategoriesServer struct {
	grpc.ServerStream
}

func (x *resultServiceGetImpactCategoriesServer) Send(m *Ref) error {
	return x.ServerStream.SendMsg(m)
}

func _ResultService_GetTotalInventory_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Result)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ResultServiceServer).GetTotalInventory(m, &resultServiceGetTotalInventoryServer{stream})
}

type ResultService_GetTotalInventoryServer interface {
	Send(*ResultValue) error
	grpc.ServerStream
}

type resultServiceGetTotalInventoryServer struct {
	grpc.ServerStream
}

func (x *resultServiceGetTotalInventoryServer) Send(m *ResultValue) error {
	return x.ServerStream.SendMsg(m)
}

func _ResultService_GetTotalImpacts_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Result)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ResultServiceServer).GetTotalImpacts(m, &resultServiceGetTotalImpactsServer{stream})
}

type ResultService_GetTotalImpactsServer interface {
	Send(*ResultValue) error
	grpc.ServerStream
}

type resultServiceGetTotalImpactsServer struct {
	grpc.ServerStream
}

func (x *resultServiceGetTotalImpactsServer) Send(m *ResultValue) error {
	return x.ServerStream.SendMsg(m)
}

func _ResultService_GetDirectContribution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TechFlowContributionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResultServiceServer).GetDirectContribution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.ResultService/GetDirectContribution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResultServiceServer).GetDirectContribution(ctx, req.(*TechFlowContributionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResultService_GetTotalContribution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TechFlowContributionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResultServiceServer).GetTotalContribution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.ResultService/GetTotalContribution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResultServiceServer).GetTotalContribution(ctx, req.(*TechFlowContributionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResultService_GetTotalContributionOfOne_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TechFlowContributionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResultServiceServer).GetTotalContributionOfOne(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.ResultService/GetTotalContributionOfOne",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResultServiceServer).GetTotalContributionOfOne(ctx, req.(*TechFlowContributionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResultService_GetImpactFactors_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ImpactFactorRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ResultServiceServer).GetImpactFactors(m, &resultServiceGetImpactFactorsServer{stream})
}

type ResultService_GetImpactFactorsServer interface {
	Send(*ImpactFactorResponse) error
	grpc.ServerStream
}

type resultServiceGetImpactFactorsServer struct {
	grpc.ServerStream
}

func (x *resultServiceGetImpactFactorsServer) Send(m *ImpactFactorResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ResultService_Dispose_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Result)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResultServiceServer).Dispose(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protolca.services.ResultService/Dispose",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResultServiceServer).Dispose(ctx, req.(*Result))
	}
	return interceptor(ctx, in, info, handler)
}

// ResultService_ServiceDesc is the grpc.ServiceDesc for ResultService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ResultService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "protolca.services.ResultService",
	HandlerType: (*ResultServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Calculate",
			Handler:    _ResultService_Calculate_Handler,
		},
		{
			MethodName: "GetDirectContribution",
			Handler:    _ResultService_GetDirectContribution_Handler,
		},
		{
			MethodName: "GetTotalContribution",
			Handler:    _ResultService_GetTotalContribution_Handler,
		},
		{
			MethodName: "GetTotalContributionOfOne",
			Handler:    _ResultService_GetTotalContributionOfOne_Handler,
		},
		{
			MethodName: "Dispose",
			Handler:    _ResultService_Dispose_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetTechFlows",
			Handler:       _ResultService_GetTechFlows_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetEnviFlows",
			Handler:       _ResultService_GetEnviFlows_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetImpactCategories",
			Handler:       _ResultService_GetImpactCategories_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetTotalInventory",
			Handler:       _ResultService_GetTotalInventory_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetTotalImpacts",
			Handler:       _ResultService_GetTotalImpacts_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetImpactFactors",
			Handler:       _ResultService_GetImpactFactors_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "results.proto",
}
